## Generics (জেনেরিকস)
TypeScript-এ, জেনেরিক্স মূলত এক ধরনের টুল যা আপনাকে পুনরায় ব্যবহারযোগ্য কোড উপাদান তৈরি করতে সক্ষম করে, যা একটি একক টাইপ পরিবর্তে বেশ কয়েকটি টাইপের সাথে কাজ করে। এটি ব্যবহারকারীদের এই `component` ব্যবহার করতে এবং তাদের নিজস্ব প্রকারগুলি ব্যবহার করতে দেয়৷

এই লিখাটি জেনেরিকগুলি কী এবং কীভাবে সেগুলি এই আইটেমগুলির জন্য ব্যবহার করা যেতে পারে তা ব্যাখ্যা করবে।

সাধারণ ভাষায় জেনেরিকের পিছনে ধারণাটি প্রদর্শন করতে, নিম্নলিখিত ফাংশন, `identity()` টি লক্ষ্য করুন , যা কেবল একটি আর্গুমেন্ট নেয় এবং রিটার্ন করে :

```
function identity(arg: number): number {
    return arg;
}
```

আমাদের `identity()` ফাংশনের উদ্দেশ্য হল আমরা যে আর্গুমেন্টটি পাস করি তা ফেরত দেওয়া। এখানে সমস্যা হল যে আমরা আর্গুমেন্ট এবং রিটার্ন টাইপ উভয়ের জন্যই নাম্বার টাইপ  বরাদ্দ করেছি, ফাংশনটিকে শুধুমাত্র এই প্রিমিটিভ টাইপের  জন্য ব্যবহারযোগ্য, ফাংশনটি খুব বেশি প্রসারণযোগ্য, বা জেনেরিক নয়, আমরা এটি চাই?

আমরা প্রকৃতপক্ষে `number` কে `any` তে অদলবদল করতে পারি, তবে প্রক্রিয়াটিতে আমরা কোন টাইপ রিটার্ন করা উচিত তা নির্ধারণ করার ক্ষমতা হারাচ্ছি। 

কি করলে `identity()` ফাংশন নির্দিষ্ট টাইপ এর জন্য কাজ করবে  এবং জেনেরিক ব্যবহার করে এটি ঠিক করতে পারে। নীচে একই ফাংশন রয়েছে, এবার একটি টাইপ ভেরিয়েবল সহ:

```
function identities<T>(arg: T): T {
    return arg;
}
```

ফাংশনের নামের পরে আমরা একটি টাইপ ভেরিয়েবল, `T`, কোণীয় বন্ধনীতে অন্তর্ভুক্ত করেছি `<>`. আমরা `identify()` ফাংশন এর মধ্যে  যে টাইপ প্রবেশ করানোর চেষ্টা করছি `T` এখানে একটি প্লেসহোল্ডার হিসেবে কাজ করবে, এবং `arg` কে `number` টাইপ এর পরিবর্তে সঠিক টাইপ এসাইন করবে : সংখ্যার পরিবর্তে , `T` এখন টাইপ হিসেবে কাজ করছে।

**নোট:** টাইপ ভেরিয়েবলকে টাইপ প্যারামিটার এবং জেনেরিক প্যারামিটার হিসাবেও উল্লেখ করা হয়। এই নিবন্ধটি অফিসিয়াল টাইপস্ক্রিপ্ট ডকুমেন্টেশনের সাথে মিল রেখে টাইপ ভেরিয়েবল শব্দটি ব্যবহার করতে বেছে নেয়া হয়েছে।

`T` এর মানে `Type`, এবং সাধারণত জেনেরিক সংজ্ঞায়িত করার সময় প্রথম প্রকার ভেরিয়েবলের নাম হিসেবে ব্যবহৃত হয়। কিন্তু বাস্তবে `T` যে কোনো বৈধ নাম দিয়ে প্রতিস্থাপন করা যেতে পারে। শুধু তাই নয়, আমরা শুধুমাত্র একটি টাইপ ভেরিয়েবলের মধ্যে সীমাবদ্ধ নই — আমরা যে পরিমাণ সংজ্ঞায়িত করতে চাই তা আনতে পারি। আসুন `T` এর পাশে `U`-এর সাথে পরিচয় করিয়ে দেই এবং আমাদের ফাংশনটি প্রসারিত করি:
```
function identities<T, U>(arg1: T, arg2: U): T {
  return arg1;
}
```
এখন আমাদের কাছে একটি `identities()` ফাংশন রয়েছে যা `U` টাইপ ভেরিয়েবল যোগ করে দুটি জেনেরিক টাইপকে একসেপ্ট করে,কিন্তু রিটার্ন টাইপ `T` থেকে যায়। আমাদের ফাংশনটি এখন দুটি টাইপ গ্রহণ করে, এবং আমাদের `arg1` প্যারামিটারের মতো একই টাইপ ফেরত দেয়। 

কিন্তু যদি আমরা উভয় টাইপ এর সাথে একটি `object` রিটার্ন করতে চাই? এটি করার  একাধিক উপায় আছে, আমরা একটি `tuple` দিয়ে তা করতে পারি, আমাদের জেনেরিক টাইপ `tuple` কে এইভাবে প্রদান করে:

```
function identities<T, U>(arg1: T, arg2: U): [T , U ] {
  return [arg1,arg2];
}
```
